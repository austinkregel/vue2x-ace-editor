{"version":3,"sources":["webpack:///./node_modules/brace/mode/elixir.js"],"names":["ace","define","acequire","exports","module","oop","TextHighlightRules","ElixirHighlightRules","this","$rules","start","token","regex","push","next","include","defaultToken","comment","TODO","originalRegex","#escaped_char","#interpolated_elixir","todo","#nest_curly_and_self","#regex_sub","normalizeRules","metaData","fileTypes","firstLineMatch","foldingStartMarker","foldingStopMarker","keyEquivalent","name","scopeName","inherits","BaseFoldMode","FoldMode","Range","getFoldWidgetRange","session","foldStyle","row","range","indentationBlock","re","line","getLine","startLevel","search","startColumn","length","maxRow","getLength","startRow","endRow","level","endColumn","getFoldWidget","indent","prev","prevIndent","nextIndent","foldWidgets","call","prototype","TextMode","Mode","HighlightRules","foldingRules","$behaviour","$defaultBehaviour","lineCommentStart","$id"],"mappings":"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","file":"js/chunk-2d0f0411.87fb8317.js","sourcesContent":["ace.define(\"ace/mode/elixir_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\nvar ElixirHighlightRules = function() {\n\n    this.$rules = { start: \n       [ { token: \n            [ 'meta.module.elixir',\n              'keyword.control.module.elixir',\n              'meta.module.elixir',\n              'entity.name.type.module.elixir' ],\n           regex: '^(\\\\s*)(defmodule)(\\\\s+)((?:[A-Z]\\\\w*\\\\s*\\\\.\\\\s*)*[A-Z]\\\\w*)' },\n         { token: 'comment.documentation.heredoc',\n           regex: '@(?:module|type)?doc (?:~[a-z])?\"\"\"',\n           push: \n            [ { token: 'comment.documentation.heredoc',\n                regex: '\\\\s*\"\"\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'comment.documentation.heredoc' } ],\n           comment: '@doc with heredocs is treated as documentation' },\n         { token: 'comment.documentation.heredoc',\n           regex: '@(?:module|type)?doc ~[A-Z]\"\"\"',\n           push: \n            [ { token: 'comment.documentation.heredoc',\n                regex: '\\\\s*\"\"\"',\n                next: 'pop' },\n              { defaultToken: 'comment.documentation.heredoc' } ],\n           comment: '@doc with heredocs is treated as documentation' },\n         { token: 'comment.documentation.heredoc',\n           regex: '@(?:module|type)?doc (?:~[a-z])?\\'\\'\\'',\n           push: \n            [ { token: 'comment.documentation.heredoc',\n                regex: '\\\\s*\\'\\'\\'',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'comment.documentation.heredoc' } ],\n           comment: '@doc with heredocs is treated as documentation' },\n         { token: 'comment.documentation.heredoc',\n           regex: '@(?:module|type)?doc ~[A-Z]\\'\\'\\'',\n           push: \n            [ { token: 'comment.documentation.heredoc',\n                regex: '\\\\s*\\'\\'\\'',\n                next: 'pop' },\n              { defaultToken: 'comment.documentation.heredoc' } ],\n           comment: '@doc with heredocs is treated as documentation' },\n         { token: 'comment.documentation.false',\n           regex: '@(?:module|type)?doc false',\n           comment: '@doc false is treated as documentation' },\n         { token: 'comment.documentation.string',\n           regex: '@(?:module|type)?doc \"',\n           push: \n            [ { token: 'comment.documentation.string',\n                regex: '\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'comment.documentation.string' } ],\n           comment: '@doc with string is treated as documentation' },\n         { token: 'keyword.control.elixir',\n           regex: '\\\\b(?:do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|acequire|alias|use|quote|unquote|super)\\\\b(?![?!])',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?<!\\\\.)\\\\b(do|end|case|bc|lc|for|if|cond|unless|try|receive|fn|defmodule|defp?|defprotocol|defimpl|defrecord|defstruct|defmacrop?|defdelegate|defcallback|defmacrocallback|defexception|defoverridable|exit|after|rescue|catch|else|raise|throw|import|acequire|alias|use|quote|unquote|super)\\\\b(?![?!])' },\n         { token: 'keyword.operator.elixir',\n           regex: '\\\\b(?:and|not|or|when|xor|in|inlist|inbits)\\\\b',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?<!\\\\.)\\\\b(and|not|or|when|xor|in|inlist|inbits)\\\\b',\n           comment: ' as above, just doesn\\'t need a \\'end\\' and does a logic operation' },\n         { token: 'constant.language.elixir',\n           regex: '\\\\b(?:nil|true|false)\\\\b(?![?!])' },\n         { token: 'variable.language.elixir',\n           regex: '\\\\b__(?:CALLER|ENV|MODULE|DIR)__\\\\b(?![?!])' },\n         { token: \n            [ 'punctuation.definition.variable.elixir',\n              'variable.other.readwrite.module.elixir' ],\n           regex: '(@)([a-zA-Z_]\\\\w*)' },\n         { token: \n            [ 'punctuation.definition.variable.elixir',\n              'variable.other.anonymous.elixir' ],\n           regex: '(&)(\\\\d*)' },\n         { token: 'variable.other.constant.elixir',\n           regex: '\\\\b[A-Z]\\\\w*\\\\b' },\n         { token: 'constant.numeric.elixir',\n           regex: '\\\\b(?:0x[\\\\da-fA-F](?:_?[\\\\da-fA-F])*|\\\\d(?:_?\\\\d)*(?:\\\\.(?![^[:space:][:digit:]])(?:_?\\\\d)*)?(?:[eE][-+]?\\\\d(?:_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '\\\\b(0x\\\\h(?>_?\\\\h)*|\\\\d(?>_?\\\\d)*(\\\\.(?![^[:space:][:digit:]])(?>_?\\\\d)*)?([eE][-+]?\\\\d(?>_?\\\\d)*)?|0b[01]+|0o[0-7]+)\\\\b' },\n         { token: 'punctuation.definition.constant.elixir',\n           regex: ':\\'',\n           push: \n            [ { token: 'punctuation.definition.constant.elixir',\n                regex: '\\'',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'constant.other.symbol.single-quoted.elixir' } ] },\n         { token: 'punctuation.definition.constant.elixir',\n           regex: ':\"',\n           push: \n            [ { token: 'punctuation.definition.constant.elixir',\n                regex: '\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'constant.other.symbol.double-quoted.elixir' } ] },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '(?:\\'\\'\\')',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?>\\'\\'\\')',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '^\\\\s*\\'\\'\\'',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'support.function.variable.quoted.single.heredoc.elixir' } ],\n           comment: 'Single-quoted heredocs' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '\\'',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\'',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'support.function.variable.quoted.single.elixir' } ],\n           comment: 'single quoted string (allows for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '(?:\"\"\")',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?>\"\"\")',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '^\\\\s*\"\"\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.quoted.double.heredoc.elixir' } ],\n           comment: 'Double-quoted heredocs' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '\"',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.quoted.double.elixir' } ],\n           comment: 'double quoted string (allows for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z](?:\"\"\")',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '~[a-z](?>\"\"\")',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '^\\\\s*\"\"\"',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.quoted.double.heredoc.elixir' } ],\n           comment: 'Double-quoted heredocs sigils' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z]\\\\{',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\}[a-z]*',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.interpolated.elixir' } ],\n           comment: 'sigil (allow for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z]\\\\[',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\][a-z]*',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.interpolated.elixir' } ],\n           comment: 'sigil (allow for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z]\\\\<',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\>[a-z]*',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.interpolated.elixir' } ],\n           comment: 'sigil (allow for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z]\\\\(',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\)[a-z]*',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.interpolated.elixir' } ],\n           comment: 'sigil (allow for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[a-z][^\\\\w]',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '[^\\\\w][a-z]*',\n                next: 'pop' },\n              { include: '#interpolated_elixir' },\n              { include: '#escaped_char' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.interpolated.elixir' } ],\n           comment: 'sigil (allow for interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z](?:\"\"\")',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '~[A-Z](?>\"\"\")',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '^\\\\s*\"\"\"',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'Double-quoted heredocs sigils' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z]\\\\{',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\}[a-z]*',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'sigil (without interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z]\\\\[',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\][a-z]*',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'sigil (without interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z]\\\\<',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\>[a-z]*',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'sigil (without interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z]\\\\(',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '\\\\)[a-z]*',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'sigil (without interpolation)' },\n         { token: 'punctuation.definition.string.begin.elixir',\n           regex: '~[A-Z][^\\\\w]',\n           push: \n            [ { token: 'punctuation.definition.string.end.elixir',\n                regex: '[^\\\\w][a-z]*',\n                next: 'pop' },\n              { defaultToken: 'string.quoted.other.literal.upper.elixir' } ],\n           comment: 'sigil (without interpolation)' },\n         { token: ['punctuation.definition.constant.elixir', 'constant.other.symbol.elixir'],\n           regex: '(:)([a-zA-Z_][\\\\w@]*(?:[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(?:\\\\^\\\\^)?)',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?<!:)(:)(?>[a-zA-Z_][\\\\w@]*(?>[?!]|=(?![>=]))?|\\\\<\\\\>|===?|!==?|<<>>|<<<|>>>|~~~|::|<\\\\-|\\\\|>|=>|~|~=|=|/|\\\\\\\\\\\\\\\\|\\\\*\\\\*?|\\\\.\\\\.?\\\\.?|>=?|<=?|&&?&?|\\\\+\\\\+?|\\\\-\\\\-?|\\\\|\\\\|?\\\\|?|\\\\!|@|\\\\%?\\\\{\\\\}|%|\\\\[\\\\]|\\\\^(\\\\^\\\\^)?)',\n           comment: 'symbols' },\n         { token: 'punctuation.definition.constant.elixir',\n           regex: '(?:[a-zA-Z_][\\\\w@]*(?:[?!])?):(?!:)',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?>[a-zA-Z_][\\\\w@]*(?>[?!])?)(:)(?!:)',\n           comment: 'symbols' },\n         { token: \n            [ 'punctuation.definition.comment.elixir',\n              'comment.line.number-sign.elixir' ],\n           regex: '(#)(.*)' },\n         { token: 'constant.numeric.elixir',\n           regex: '\\\\?(?:\\\\\\\\(?:x[\\\\da-fA-F]{1,2}(?![\\\\da-fA-F])\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n           TODO: 'FIXME: regexp doesn\\'t have js equivalent',\n           originalRegex: '(?<!\\\\w)\\\\?(\\\\\\\\(x\\\\h{1,2}(?!\\\\h)\\\\b|[^xMC])|[^\\\\s\\\\\\\\])',\n           comment: '\\n\\t\\t\\tmatches questionmark-letters.\\n\\n\\t\\t\\texamples (1st alternation = hex):\\n\\t\\t\\t?\\\\x1     ?\\\\x61\\n\\n\\t\\t\\texamples (2rd alternation = escaped):\\n\\t\\t\\t?\\\\n      ?\\\\b\\n\\n\\t\\t\\texamples (3rd alternation = normal):\\n\\t\\t\\t?a       ?A       ?0 \\n\\t\\t\\t?*       ?\"       ?( \\n\\t\\t\\t?.       ?#\\n\\t\\t\\t\\n\\t\\t\\tthe negative lookbehind prevents against matching\\n\\t\\t\\tp(42.tainted?)\\n\\t\\t\\t' },\n         { token: 'keyword.operator.assignment.augmented.elixir',\n           regex: '\\\\+=|\\\\-=|\\\\|\\\\|=|~=|&&=' },\n         { token: 'keyword.operator.comparison.elixir',\n           regex: '===?|!==?|<=?|>=?' },\n         { token: 'keyword.operator.bitwise.elixir',\n           regex: '\\\\|{3}|&{3}|\\\\^{3}|<{3}|>{3}|~{3}' },\n         { token: 'keyword.operator.logical.elixir',\n           regex: '!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b',\n           originalRegex: '(?<=[ \\\\t])!+|\\\\bnot\\\\b|&&|\\\\band\\\\b|\\\\|\\\\||\\\\bor\\\\b|\\\\bxor\\\\b' },\n         { token: 'keyword.operator.arithmetic.elixir',\n           regex: '\\\\*|\\\\+|\\\\-|/' },\n         { token: 'keyword.operator.other.elixir',\n           regex: '\\\\||\\\\+\\\\+|\\\\-\\\\-|\\\\*\\\\*|\\\\\\\\\\\\\\\\|\\\\<\\\\-|\\\\<\\\\>|\\\\<\\\\<|\\\\>\\\\>|\\\\:\\\\:|\\\\.\\\\.|\\\\|>|~|=>' },\n         { token: 'keyword.operator.assignment.elixir', regex: '=' },\n         { token: 'punctuation.separator.other.elixir', regex: ':' },\n         { token: 'punctuation.separator.statement.elixir',\n           regex: '\\\\;' },\n         { token: 'punctuation.separator.object.elixir', regex: ',' },\n         { token: 'punctuation.separator.method.elixir', regex: '\\\\.' },\n         { token: 'punctuation.section.scope.elixir', regex: '\\\\{|\\\\}' },\n         { token: 'punctuation.section.array.elixir', regex: '\\\\[|\\\\]' },\n         { token: 'punctuation.section.function.elixir',\n           regex: '\\\\(|\\\\)' } ],\n      '#escaped_char': \n       [ { token: 'constant.character.escape.elixir',\n           regex: '\\\\\\\\(?:x[\\\\da-fA-F]{1,2}|.)' } ],\n      '#interpolated_elixir': \n       [ { token: \n            [ 'source.elixir.embedded.source',\n              'source.elixir.embedded.source.empty' ],\n           regex: '(#\\\\{)(\\\\})' },\n         { todo: \n            { token: 'punctuation.section.embedded.elixir',\n              regex: '#\\\\{',\n              push: \n               [ { token: 'punctuation.section.embedded.elixir',\n                   regex: '\\\\}',\n                   next: 'pop' },\n                 { include: '#nest_curly_and_self' },\n                 { include: '$self' },\n                 { defaultToken: 'source.elixir.embedded.source' } ] } } ],\n      '#nest_curly_and_self': \n       [ { token: 'punctuation.section.scope.elixir',\n           regex: '\\\\{',\n           push: \n            [ { token: 'punctuation.section.scope.elixir',\n                regex: '\\\\}',\n                next: 'pop' },\n              { include: '#nest_curly_and_self' } ] },\n         { include: '$self' } ],\n      '#regex_sub': \n       [ { include: '#interpolated_elixir' },\n         { include: '#escaped_char' },\n         { token: \n            [ 'punctuation.definition.arbitrary-repitition.elixir',\n              'string.regexp.arbitrary-repitition.elixir',\n              'string.regexp.arbitrary-repitition.elixir',\n              'punctuation.definition.arbitrary-repitition.elixir' ],\n           regex: '(\\\\{)(\\\\d+)((?:,\\\\d+)?)(\\\\})' },\n         { token: 'punctuation.definition.character-class.elixir',\n           regex: '\\\\[(?:\\\\^?\\\\])?',\n           push: \n            [ { token: 'punctuation.definition.character-class.elixir',\n                regex: '\\\\]',\n                next: 'pop' },\n              { include: '#escaped_char' },\n              { defaultToken: 'string.regexp.character-class.elixir' } ] },\n         { token: 'punctuation.definition.group.elixir',\n           regex: '\\\\(',\n           push: \n            [ { token: 'punctuation.definition.group.elixir',\n                regex: '\\\\)',\n                next: 'pop' },\n              { include: '#regex_sub' },\n              { defaultToken: 'string.regexp.group.elixir' } ] },\n         { token: \n            [ 'punctuation.definition.comment.elixir',\n              'comment.line.number-sign.elixir' ],\n           regex: '(?:^|\\\\s)(#)(\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x00-\\\\x7F]]*$)',\n           originalRegex: '(?<=^|\\\\s)(#)\\\\s[[a-zA-Z0-9,. \\\\t?!-][^\\\\x{00}-\\\\x{7F}]]*$',\n           comment: 'We are restrictive in what we allow to go after the comment character to avoid false positives, since the availability of comments depend on regexp flags.' } ] };\n    \n    this.normalizeRules();\n};\n\nElixirHighlightRules.metaData = { comment: 'Textmate bundle for Elixir Programming Language.',\n      fileTypes: [ 'ex', 'exs' ],\n      firstLineMatch: '^#!/.*\\\\belixir',\n      foldingStartMarker: '(after|else|catch|rescue|\\\\-\\\\>|\\\\{|\\\\[|do)\\\\s*$',\n      foldingStopMarker: '^\\\\s*((\\\\}|\\\\]|after|else|catch|rescue)\\\\s*$|end\\\\b)',\n      keyEquivalent: '^~E',\n      name: 'Elixir',\n      scopeName: 'source.elixir' };\n\n\noop.inherits(ElixirHighlightRules, TextHighlightRules);\n\nexports.ElixirHighlightRules = ElixirHighlightRules;\n});\n\nace.define(\"ace/mode/folding/coffee\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../../lib/oop\");\nvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\nvar Range = acequire(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n\n            if (level == -1)\n                continue;\n\n            if (line[level] != \"#\")\n                break;\n\n            endRow = row;\n        }\n\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent!= -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        } else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n\n        if (prevIndent!= -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/elixir\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/elixir_highlight_rules\",\"ace/mode/folding/coffee\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar ElixirHighlightRules = acequire(\"./elixir_highlight_rules\").ElixirHighlightRules;\nvar FoldMode = acequire(\"./folding/coffee\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = ElixirHighlightRules;\n    this.foldingRules = new FoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.lineCommentStart = \"#\";\n    this.$id = \"ace/mode/elixir\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n"],"sourceRoot":""}