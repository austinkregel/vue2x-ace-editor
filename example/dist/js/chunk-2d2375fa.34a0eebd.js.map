{"version":3,"sources":["webpack:///./node_modules/brace/mode/asciidoc.js"],"names":["ace","define","acequire","exports","module","oop","TextHighlightRules","AsciidocHighlightRules","identifierRe","quoteRule","ch","prefix","test","this","$rules","start","token","regex","next","dissallowDelimitedBlock","include","paragraphEnd","listStart","text","listText","indentedBlock","listingBlock","literalBlock","passthroughBlock","smallPassthrough","commentBlock","tableBlock","noEscape","innerTableBlock","macros","quotes","tokenMap","macro","titleUnderline","singleLineTitle","pageBreak","option","otherBlock","literal","optionalTitle","escape","link","state","stateRules","i","length","rule","args","concat","filter","x","splice","apply","inherits","BaseFoldMode","FoldMode","Range","foldingStartMarker","singleLineHeadingRe","getFoldWidget","session","foldStyle","row","line","getLine","bgTokenizer","getState","getFoldWidgetRange","startColumn","maxRow","getLength","startRow","endRow","match","levels","heading","getTokenType","startHeadingLevel","getLevel","level","isSingleLineHeading","value","endColumn","lastIndexOf","getTokens","type","indexOf","Infinity","call","prototype","TextMode","Mode","AsciidocFoldMode","HighlightRules","foldingRules","getNextLineIndent","tab","exec","Array","join","$getIndent","$id"],"mappings":"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","file":"js/chunk-2d2375fa.34a0eebd.js","sourcesContent":["ace.define(\"ace/mode/asciidoc_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\nvar AsciidocHighlightRules = function() {\n    var identifierRe = \"[a-zA-Z\\u00a1-\\uffff]+\\\\b\";\n\n    this.$rules = {\n        \"start\": [\n            {token: \"empty\",   regex: /$/},\n            {token: \"literal\", regex: /^\\.{4,}\\s*$/,  next: \"listingBlock\"},\n            {token: \"literal\", regex: /^-{4,}\\s*$/,   next: \"literalBlock\"},\n            {token: \"string\",  regex: /^\\+{4,}\\s*$/,  next: \"passthroughBlock\"},\n            {token: \"keyword\", regex: /^={4,}\\s*$/},\n            {token: \"text\",    regex: /^\\s*$/},\n            {token: \"empty\", regex: \"\", next: \"dissallowDelimitedBlock\"}\n        ],\n\n        \"dissallowDelimitedBlock\": [\n            {include: \"paragraphEnd\"},\n            {token: \"comment\", regex: '^//.+$'},\n            {token: \"keyword\", regex: \"^(?:NOTE|TIP|IMPORTANT|WARNING|CAUTION):\"},\n\n            {include: \"listStart\"},\n            {token: \"literal\", regex: /^\\s+.+$/, next: \"indentedBlock\"},\n            {token: \"empty\",   regex: \"\", next: \"text\"}\n        ],\n\n        \"paragraphEnd\": [\n            {token: \"doc.comment\", regex: /^\\/{4,}\\s*$/,    next: \"commentBlock\"},\n            {token: \"tableBlock\",  regex: /^\\s*[|!]=+\\s*$/, next: \"tableBlock\"},\n            {token: \"keyword\",     regex: /^(?:--|''')\\s*$/, next: \"start\"},\n            {token: \"option\",      regex: /^\\[.*\\]\\s*$/,     next: \"start\"},\n            {token: \"pageBreak\",   regex: /^>{3,}$/,         next: \"start\"},\n            {token: \"literal\",     regex: /^\\.{4,}\\s*$/,     next: \"listingBlock\"},\n            {token: \"titleUnderline\",    regex: /^(?:={2,}|-{2,}|~{2,}|\\^{2,}|\\+{2,})\\s*$/, next: \"start\"},\n            {token: \"singleLineTitle\",   regex: /^={1,5}\\s+\\S.*$/, next: \"start\"},\n\n            {token: \"otherBlock\",    regex: /^(?:\\*{2,}|_{2,})\\s*$/, next: \"start\"},\n            {token: \"optionalTitle\", regex: /^\\.[^.\\s].+$/,  next: \"start\"}\n        ],\n\n        \"listStart\": [\n            {token: \"keyword\",  regex: /^\\s*(?:\\d+\\.|[a-zA-Z]\\.|[ixvmIXVM]+\\)|\\*{1,5}|-|\\.{1,5})\\s/, next: \"listText\"},\n            {token: \"meta.tag\", regex: /^.+(?::{2,4}|;;)(?: |$)/, next: \"listText\"},\n            {token: \"support.function.list.callout\", regex: /^(?:<\\d+>|\\d+>|>) /, next: \"text\"},\n            {token: \"keyword\",  regex: /^\\+\\s*$/, next: \"start\"}\n        ],\n\n        \"text\": [\n            {token: [\"link\", \"variable.language\"], regex: /((?:https?:\\/\\/|ftp:\\/\\/|file:\\/\\/|mailto:|callto:)[^\\s\\[]+)(\\[.*?\\])/},\n            {token: \"link\", regex: /(?:https?:\\/\\/|ftp:\\/\\/|file:\\/\\/|mailto:|callto:)[^\\s\\[]+/},\n            {token: \"link\", regex: /\\b[\\w\\.\\/\\-]+@[\\w\\.\\/\\-]+\\b/},\n            {include: \"macros\"},\n            {include: \"paragraphEnd\"},\n            {token: \"literal\", regex:/\\+{3,}/, next:\"smallPassthrough\"},\n            {token: \"escape\", regex: /\\((?:C|TM|R)\\)|\\.{3}|->|<-|=>|<=|&#(?:\\d+|x[a-fA-F\\d]+);|(?: |^)--(?=\\s+\\S)/},\n            {token: \"escape\", regex: /\\\\[_*'`+#]|\\\\{2}[_*'`+#]{2}/},\n            {token: \"keyword\", regex: /\\s\\+$/},\n            {token: \"text\", regex: identifierRe},\n            {token: [\"keyword\", \"string\", \"keyword\"],\n                regex: /(<<[\\w\\d\\-$]+,)(.*?)(>>|$)/},\n            {token: \"keyword\", regex: /<<[\\w\\d\\-$]+,?|>>/},\n            {token: \"constant.character\", regex: /\\({2,3}.*?\\){2,3}/},\n            {token: \"keyword\", regex: /\\[\\[.+?\\]\\]/},\n            {token: \"support\", regex: /^\\[{3}[\\w\\d =\\-]+\\]{3}/},\n\n            {include: \"quotes\"},\n            {token: \"empty\", regex: /^\\s*$/, next: \"start\"}\n        ],\n\n        \"listText\": [\n            {include: \"listStart\"},\n            {include: \"text\"}\n        ],\n\n        \"indentedBlock\": [\n            {token: \"literal\", regex: /^[\\s\\w].+$/, next: \"indentedBlock\"},\n            {token: \"literal\", regex: \"\", next: \"start\"}\n        ],\n\n        \"listingBlock\": [\n            {token: \"literal\", regex: /^\\.{4,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n            {token: \"constant.numeric\", regex: '<\\\\d+>'},\n            {token: \"literal\", regex: '[^<]+'},\n            {token: \"literal\", regex: '<'}\n        ],\n        \"literalBlock\": [\n            {token: \"literal\", regex: /^-{4,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n            {token: \"constant.numeric\", regex: '<\\\\d+>'},\n            {token: \"literal\", regex: '[^<]+'},\n            {token: \"literal\", regex: '<'}\n        ],\n        \"passthroughBlock\": [\n            {token: \"literal\", regex: /^\\+{4,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n            {token: \"literal\", regex: identifierRe + \"|\\\\d+\"},\n            {include: \"macros\"},\n            {token: \"literal\", regex: \".\"}\n        ],\n\n        \"smallPassthrough\": [\n            {token: \"literal\", regex: /[+]{3,}/, next: \"dissallowDelimitedBlock\"},\n            {token: \"literal\", regex: /^\\s*$/, next: \"dissallowDelimitedBlock\"},\n            {token: \"literal\", regex: identifierRe + \"|\\\\d+\"},\n            {include: \"macros\"}\n        ],\n\n        \"commentBlock\": [\n            {token: \"doc.comment\", regex: /^\\/{4,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n            {token: \"doc.comment\", regex: '^.*$'}\n        ],\n        \"tableBlock\": [\n            {token: \"tableBlock\", regex: /^\\s*\\|={3,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n            {token: \"tableBlock\", regex: /^\\s*!={3,}\\s*$/, next: \"innerTableBlock\"},\n            {token: \"tableBlock\", regex: /\\|/},\n            {include: \"text\", noEscape: true}\n        ],\n        \"innerTableBlock\": [\n            {token: \"tableBlock\", regex: /^\\s*!={3,}\\s*$/, next: \"tableBlock\"},\n            {token: \"tableBlock\", regex: /^\\s*|={3,}\\s*$/, next: \"dissallowDelimitedBlock\"},\n            {token: \"tableBlock\", regex: /!/}\n        ],\n        \"macros\": [\n            {token: \"macro\", regex: /{[\\w\\-$]+}/},\n            {token: [\"text\", \"string\", \"text\", \"constant.character\", \"text\"], regex: /({)([\\w\\-$]+)(:)?(.+)?(})/},\n            {token: [\"text\", \"markup.list.macro\", \"keyword\", \"string\"], regex: /(\\w+)(footnote(?:ref)?::?)([^\\s\\[]+)?(\\[.*?\\])?/},\n            {token: [\"markup.list.macro\", \"keyword\", \"string\"], regex: /([a-zA-Z\\-][\\w\\.\\/\\-]*::?)([^\\s\\[]+)(\\[.*?\\])?/},\n            {token: [\"markup.list.macro\", \"keyword\"], regex: /([a-zA-Z\\-][\\w\\.\\/\\-]+::?)(\\[.*?\\])/},\n            {token: \"keyword\",     regex: /^:.+?:(?= |$)/}\n        ],\n\n        \"quotes\": [\n            {token: \"string.italic\", regex: /__[^_\\s].*?__/},\n            {token: \"string.italic\", regex: quoteRule(\"_\")},\n            \n            {token: \"keyword.bold\", regex: /\\*\\*[^*\\s].*?\\*\\*/},\n            {token: \"keyword.bold\", regex: quoteRule(\"\\\\*\")},\n            \n            {token: \"literal\", regex: quoteRule(\"\\\\+\")},\n            {token: \"literal\", regex: /\\+\\+[^+\\s].*?\\+\\+/},\n            {token: \"literal\", regex: /\\$\\$.+?\\$\\$/},\n            {token: \"literal\", regex: quoteRule(\"`\")},\n\n            {token: \"keyword\", regex: quoteRule(\"^\")},\n            {token: \"keyword\", regex: quoteRule(\"~\")},\n            {token: \"keyword\", regex: /##?/},\n            {token: \"keyword\", regex: /(?:\\B|^)``|\\b''/}\n        ]\n\n    };\n\n    function quoteRule(ch) {\n        var prefix = /\\w/.test(ch) ? \"\\\\b\" : \"(?:\\\\B|^)\";\n        return prefix + ch + \"[^\" + ch + \"].*?\" + ch + \"(?![\\\\w*])\";\n    }\n\n    var tokenMap = {\n        macro: \"constant.character\",\n        tableBlock: \"doc.comment\",\n        titleUnderline: \"markup.heading\",\n        singleLineTitle: \"markup.heading\",\n        pageBreak: \"string\",\n        option: \"string.regexp\",\n        otherBlock: \"markup.list\",\n        literal: \"support.function\",\n        optionalTitle: \"constant.numeric\",\n        escape: \"constant.language.escape\",\n        link: \"markup.underline.list\"\n    };\n\n    for (var state in this.$rules) {\n        var stateRules = this.$rules[state];\n        for (var i = stateRules.length; i--; ) {\n            var rule = stateRules[i];\n            if (rule.include || typeof rule == \"string\") {\n                var args = [i, 1].concat(this.$rules[rule.include || rule]);\n                if (rule.noEscape) {\n                    args = args.filter(function(x) {\n                        return !x.next;\n                    });\n                }\n                stateRules.splice.apply(stateRules, args);\n            } else if (rule.token in tokenMap) {\n                rule.token = tokenMap[rule.token];\n            }\n        }\n    }\n};\noop.inherits(AsciidocHighlightRules, TextHighlightRules);\n\nexports.AsciidocHighlightRules = AsciidocHighlightRules;\n});\n\nace.define(\"ace/mode/folding/asciidoc\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../../lib/oop\");\nvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\nvar Range = acequire(\"../../range\").Range;\n\nvar FoldMode = exports.FoldMode = function() {};\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n    this.foldingStartMarker = /^(?:\\|={10,}|[\\.\\/=\\-~^+]{4,}\\s*$|={1,5} )/;\n    this.singleLineHeadingRe = /^={1,5}(?=\\s+\\S)/;\n\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        if (!this.foldingStartMarker.test(line))\n            return \"\";\n\n        if (line[0] == \"=\") {\n            if (this.singleLineHeadingRe.test(line))\n                return \"start\";\n            if (session.getLine(row - 1).length != session.getLine(row).length)\n                return \"\";\n            return \"start\";\n        }\n        if (session.bgTokenizer.getState(row) == \"dissallowDelimitedBlock\")\n            return \"end\";\n        return \"start\";\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n        if (!line.match(this.foldingStartMarker))\n            return;\n\n        var token;\n        function getTokenType(row) {\n            token = session.getTokens(row)[0];\n            return token && token.type;\n        }\n\n        var levels = [\"=\",\"-\",\"~\",\"^\",\"+\"];\n        var heading = \"markup.heading\";\n        var singleLineHeadingRe = this.singleLineHeadingRe;\n        function getLevel() {\n            var match = token.value.match(singleLineHeadingRe);\n            if (match)\n                return match[0].length;\n            var level = levels.indexOf(token.value[0]) + 1;\n            if (level == 1) {\n                if (session.getLine(row - 1).length != session.getLine(row).length)\n                    return Infinity;\n            }\n            return level;\n        }\n\n        if (getTokenType(row) == heading) {\n            var startHeadingLevel = getLevel();\n            while (++row < maxRow) {\n                if (getTokenType(row) != heading)\n                    continue;\n                var level = getLevel();\n                if (level <= startHeadingLevel)\n                    break;\n            }\n\n            var isSingleLineHeading = token && token.value.match(this.singleLineHeadingRe);\n            endRow = isSingleLineHeading ? row - 1 : row - 2;\n\n            if (endRow > startRow) {\n                while (endRow > startRow && (!getTokenType(endRow) || token.value[0] == \"[\"))\n                    endRow--;\n            }\n\n            if (endRow > startRow) {\n                var endColumn = session.getLine(endRow).length;\n                return new Range(startRow, startColumn, endRow, endColumn);\n            }\n        } else {\n            var state = session.bgTokenizer.getState(row);\n            if (state == \"dissallowDelimitedBlock\") {\n                while (row -- > 0) {\n                    if (session.bgTokenizer.getState(row).lastIndexOf(\"Block\") == -1)\n                        break;\n                }\n                endRow = row + 1;\n                if (endRow < startRow) {\n                    var endColumn = session.getLine(row).length;\n                    return new Range(endRow, 5, startRow, startColumn - 5);\n                }\n            } else {\n                while (++row < maxRow) {\n                    if (session.bgTokenizer.getState(row) == \"dissallowDelimitedBlock\")\n                        break;\n                }\n                endRow = row;\n                if (endRow > startRow) {\n                    var endColumn = session.getLine(row).length;\n                    return new Range(startRow, 5, endRow, endColumn - 5);\n                }\n            }\n        }\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/asciidoc\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/asciidoc_highlight_rules\",\"ace/mode/folding/asciidoc\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar AsciidocHighlightRules = acequire(\"./asciidoc_highlight_rules\").AsciidocHighlightRules;\nvar AsciidocFoldMode = acequire(\"./folding/asciidoc\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = AsciidocHighlightRules;\n    \n    this.foldingRules = new AsciidocFoldMode();    \n};\noop.inherits(Mode, TextMode);\n\n(function() {\n    this.type = \"text\";\n    this.getNextLineIndent = function(state, line, tab) {\n        if (state == \"listblock\") {\n            var match = /^((?:.+)?)([-+*][ ]+)/.exec(line);\n            if (match) {\n                return new Array(match[1].length + 1).join(\" \") + match[2];\n            } else {\n                return \"\";\n            }\n        } else {\n            return this.$getIndent(line);\n        }\n    };\n    this.$id = \"ace/mode/asciidoc\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n"],"sourceRoot":""}