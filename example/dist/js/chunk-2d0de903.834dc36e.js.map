{"version":3,"sources":["webpack:///./node_modules/brace/mode/lua.js"],"names":["ace","define","acequire","exports","module","oop","TextHighlightRules","LuaHighlightRules","keywords","builtinConstants","functions","stdLibaries","deprecatedIn5152","keywordMapper","this","createKeywordMapper","keyword","support.function","keyword.deprecated","constant.library","constant.language","variable.language","decimalInteger","hexInteger","integer","fraction","intPart","pointFloat","floatNumber","$rules","start","stateName","onMatch","value","currentState","stack","unshift","next","length","regex","shift","defaultToken","token","normalizeRules","inherits","BaseFoldMode","FoldMode","Range","TokenIterator","foldingStartMarker","foldingStopMarker","getFoldWidget","session","foldStyle","row","line","getLine","isStart","test","isEnd","match","getTokenAt","index","type","bgTokenizer","getState","getFoldWidgetRange","doc","exec","luaBlock","getCommentFoldRange","openingBracketBlock","closingBracketBlock","column","stream","indentKeywords","function","do","then","elseif","end","repeat","until","getCurrentToken","val","dir","startColumn","getCurrentTokenColumn","startRow","step","stepBackward","stepForward","level","getCurrentTokenRow","call","prototype","TextMode","Mode","LuaFoldMode","WorkerClient","HighlightRules","foldingRules","$behaviour","$defaultBehaviour","lineCommentStart","blockComment","else","outdentKeywords","getNetIndentLevel","tokens","i","getNextLineIndent","state","tab","indent","$getIndent","tokenizedLine","getTokenizer","getLineTokens","substr","checkOutdent","input","trim","indexOf","autoOutdent","prevLine","prevIndent","prevTokens","tabLength","getTabString","expectedIndent","curIndent","outdentRows","createWorker","worker","__webpack_require__","attachToDocument","getDocument","on","e","setAnnotations","data","clearAnnotations","$id"],"mappings":"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","file":"js/chunk-2d0de903.834dc36e.js","sourcesContent":["ace.define(\"ace/mode/lua_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextHighlightRules = acequire(\"./text_highlight_rules\").TextHighlightRules;\n\nvar LuaHighlightRules = function() {\n\n    var keywords = (\n        \"break|do|else|elseif|end|for|function|if|in|local|repeat|\"+\n         \"return|then|until|while|or|and|not\"\n    );\n\n    var builtinConstants = (\"true|false|nil|_G|_VERSION\");\n\n    var functions = (\n        \"string|xpcall|package|tostring|print|os|unpack|acequire|\"+\n        \"getfenv|setmetatable|next|assert|tonumber|io|rawequal|\"+\n        \"collectgarbage|getmetatable|module|rawset|math|debug|\"+\n        \"pcall|table|newproxy|type|coroutine|_G|select|gcinfo|\"+\n        \"pairs|rawget|loadstring|ipairs|_VERSION|dofile|setfenv|\"+\n        \"load|error|loadfile|\"+\n\n        \"sub|upper|len|gfind|rep|find|match|char|dump|gmatch|\"+\n        \"reverse|byte|format|gsub|lower|preload|loadlib|loaded|\"+\n        \"loaders|cpath|config|path|seeall|exit|setlocale|date|\"+\n        \"getenv|difftime|remove|time|clock|tmpname|rename|execute|\"+\n        \"lines|write|close|flush|open|output|type|read|stderr|\"+\n        \"stdin|input|stdout|popen|tmpfile|log|max|acos|huge|\"+\n        \"ldexp|pi|cos|tanh|pow|deg|tan|cosh|sinh|random|randomseed|\"+\n        \"frexp|ceil|floor|rad|abs|sqrt|modf|asin|min|mod|fmod|log10|\"+\n        \"atan2|exp|sin|atan|getupvalue|debug|sethook|getmetatable|\"+\n        \"gethook|setmetatable|setlocal|traceback|setfenv|getinfo|\"+\n        \"setupvalue|getlocal|getregistry|getfenv|setn|insert|getn|\"+\n        \"foreachi|maxn|foreach|concat|sort|remove|resume|yield|\"+\n        \"status|wrap|create|running|\"+\n        \"__add|__sub|__mod|__unm|__concat|__lt|__index|__call|__gc|__metatable|\"+\n         \"__mul|__div|__pow|__len|__eq|__le|__newindex|__tostring|__mode|__tonumber\"\n    );\n\n    var stdLibaries = (\"string|package|os|io|math|debug|table|coroutine\");\n\n    var deprecatedIn5152 = (\"setn|foreach|foreachi|gcinfo|log10|maxn\");\n\n    var keywordMapper = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"support.function\": functions,\n        \"keyword.deprecated\": deprecatedIn5152,\n        \"constant.library\": stdLibaries,\n        \"constant.language\": builtinConstants,\n        \"variable.language\": \"self\"\n    }, \"identifier\");\n\n    var decimalInteger = \"(?:(?:[1-9]\\\\d*)|(?:0))\";\n    var hexInteger = \"(?:0[xX][\\\\dA-Fa-f]+)\";\n    var integer = \"(?:\" + decimalInteger + \"|\" + hexInteger + \")\";\n\n    var fraction = \"(?:\\\\.\\\\d+)\";\n    var intPart = \"(?:\\\\d+)\";\n    var pointFloat = \"(?:(?:\" + intPart + \"?\" + fraction + \")|(?:\" + intPart + \"\\\\.))\";\n    var floatNumber = \"(?:\" + pointFloat + \")\";\n\n    this.$rules = {\n        \"start\" : [{\n            stateName: \"bracketedComment\",\n            onMatch : function(value, currentState, stack){\n                stack.unshift(this.next, value.length - 2, currentState);\n                return \"comment\";\n            },\n            regex : /\\-\\-\\[=*\\[/,\n            next  : [\n                {\n                    onMatch : function(value, currentState, stack) {\n                        if (value.length == stack[1]) {\n                            stack.shift();\n                            stack.shift();\n                            this.next = stack.shift();\n                        } else {\n                            this.next = \"\";\n                        }\n                        return \"comment\";\n                    },\n                    regex : /\\]=*\\]/,\n                    next  : \"start\"\n                }, {\n                    defaultToken : \"comment\"\n                }\n            ]\n        },\n\n        {\n            token : \"comment\",\n            regex : \"\\\\-\\\\-.*$\"\n        },\n        {\n            stateName: \"bracketedString\",\n            onMatch : function(value, currentState, stack){\n                stack.unshift(this.next, value.length, currentState);\n                return \"string.start\";\n            },\n            regex : /\\[=*\\[/,\n            next  : [\n                {\n                    onMatch : function(value, currentState, stack) {\n                        if (value.length == stack[1]) {\n                            stack.shift();\n                            stack.shift();\n                            this.next = stack.shift();\n                        } else {\n                            this.next = \"\";\n                        }\n                        return \"string.end\";\n                    },\n                    \n                    regex : /\\]=*\\]/,\n                    next  : \"start\"\n                }, {\n                    defaultToken : \"string\"\n                }\n            ]\n        },\n        {\n            token : \"string\",           // \" string\n            regex : '\"(?:[^\\\\\\\\]|\\\\\\\\.)*?\"'\n        }, {\n            token : \"string\",           // ' string\n            regex : \"'(?:[^\\\\\\\\]|\\\\\\\\.)*?'\"\n        }, {\n            token : \"constant.numeric\", // float\n            regex : floatNumber\n        }, {\n            token : \"constant.numeric\", // integer\n            regex : integer + \"\\\\b\"\n        }, {\n            token : keywordMapper,\n            regex : \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n        }, {\n            token : \"keyword.operator\",\n            regex : \"\\\\+|\\\\-|\\\\*|\\\\/|%|\\\\#|\\\\^|~|<|>|<=|=>|==|~=|=|\\\\:|\\\\.\\\\.\\\\.|\\\\.\\\\.\"\n        }, {\n            token : \"paren.lparen\",\n            regex : \"[\\\\[\\\\(\\\\{]\"\n        }, {\n            token : \"paren.rparen\",\n            regex : \"[\\\\]\\\\)\\\\}]\"\n        }, {\n            token : \"text\",\n            regex : \"\\\\s+|\\\\w+\"\n        } ]\n    };\n    \n    this.normalizeRules();\n};\n\noop.inherits(LuaHighlightRules, TextHighlightRules);\n\nexports.LuaHighlightRules = LuaHighlightRules;\n});\n\nace.define(\"ace/mode/folding/lua\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../../lib/oop\");\nvar BaseFoldMode = acequire(\"./fold_mode\").FoldMode;\nvar Range = acequire(\"../../range\").Range;\nvar TokenIterator = acequire(\"../../token_iterator\").TokenIterator;\n\n\nvar FoldMode = exports.FoldMode = function() {};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function() {\n\n    this.foldingStartMarker = /\\b(function|then|do|repeat)\\b|{\\s*$|(\\[=*\\[)/;\n    this.foldingStopMarker = /\\bend\\b|^\\s*}|\\]=*\\]/;\n\n    this.getFoldWidget = function(session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n\n        if (isStart && !isEnd) {\n            var match = line.match(this.foldingStartMarker);\n            if (match[1] == \"then\" && /\\belseif\\b/.test(line))\n                return;\n            if (match[1]) {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return \"start\";\n            } else if (match[2]) {\n                var type = session.bgTokenizer.getState(row) || \"\";\n                if (type[0] == \"bracketedComment\" || type[0] == \"bracketedString\")\n                    return \"start\";\n            } else {\n                return \"start\";\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n\n        var match = line.match(this.foldingStopMarker);\n        if (match[0] === \"end\") {\n            if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                return \"end\";\n        } else if (match[0][0] === \"]\") {\n            var type = session.bgTokenizer.getState(row - 1) || \"\";\n            if (type[0] == \"bracketedComment\" || type[0] == \"bracketedString\")\n                return \"end\";\n        } else\n            return \"end\";\n    };\n\n    this.getFoldWidgetRange = function(session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1])\n                return this.luaBlock(session, row, match.index + 1);\n\n            if (match[2])\n                return session.getCommentFoldRange(row, match.index + 1);\n\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[0] === \"end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return this.luaBlock(session, row, match.index + 1);\n            }\n\n            if (match[0][0] === \"]\")\n                return session.getCommentFoldRange(row, match.index + 1);\n\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n\n    this.luaBlock = function(session, row, column) {\n        var stream = new TokenIterator(session, row, column);\n        var indentKeywords = {\n            \"function\": 1,\n            \"do\": 1,\n            \"then\": 1,\n            \"elseif\": -1,\n            \"end\": -1,\n            \"repeat\": 1,\n            \"until\": -1\n        };\n\n        var token = stream.getCurrentToken();\n        if (!token || token.type != \"keyword\")\n            return;\n\n        var val = token.value;\n        var stack = [val];\n        var dir = indentKeywords[val];\n\n        if (!dir)\n            return;\n\n        var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n        var startRow = row;\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        while(token = stream.step()) {\n            if (token.type !== \"keyword\")\n                continue;\n            var level = dir * indentKeywords[token.value];\n\n            if (level > 0) {\n                stack.unshift(token.value);\n            } else if (level <= 0) {\n                stack.shift();\n                if (!stack.length && token.value != \"elseif\")\n                    break;\n                if (level === 0)\n                    stack.unshift(token.value);\n            }\n        }\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1)\n            return new Range(row, session.getLine(row).length, startRow, startColumn);\n        else\n            return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/lua\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/lua_highlight_rules\",\"ace/mode/folding/lua\",\"ace/range\",\"ace/worker/worker_client\"], function(acequire, exports, module) {\n\"use strict\";\n\nvar oop = acequire(\"../lib/oop\");\nvar TextMode = acequire(\"./text\").Mode;\nvar LuaHighlightRules = acequire(\"./lua_highlight_rules\").LuaHighlightRules;\nvar LuaFoldMode = acequire(\"./folding/lua\").FoldMode;\nvar Range = acequire(\"../range\").Range;\nvar WorkerClient = acequire(\"../worker/worker_client\").WorkerClient;\n\nvar Mode = function() {\n    this.HighlightRules = LuaHighlightRules;\n    \n    this.foldingRules = new LuaFoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n   \n    this.lineCommentStart = \"--\";\n    this.blockComment = {start: \"--[\", end: \"]--\"};\n    \n    var indentKeywords = {\n        \"function\": 1,\n        \"then\": 1,\n        \"do\": 1,\n        \"else\": 1,\n        \"elseif\": 1,\n        \"repeat\": 1,\n        \"end\": -1,\n        \"until\": -1\n    };\n    var outdentKeywords = [\n        \"else\",\n        \"elseif\",\n        \"end\",\n        \"until\"\n    ];\n\n    function getNetIndentLevel(tokens) {\n        var level = 0;\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (token.type == \"keyword\") {\n                if (token.value in indentKeywords) {\n                    level += indentKeywords[token.value];\n                }\n            } else if (token.type == \"paren.lparen\") {\n                level += token.value.length;\n            } else if (token.type == \"paren.rparen\") {\n                level -= token.value.length;\n            }\n        }\n        if (level < 0) {\n            return -1;\n        } else if (level > 0) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n        var level = 0;\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (state == \"start\") {\n            level = getNetIndentLevel(tokens);\n        }\n        if (level > 0) {\n            return indent + tab;\n        } else if (level < 0 && indent.substr(indent.length - tab.length) == tab) {\n            if (!this.checkOutdent(state, line, \"\\n\")) {\n                return indent.substr(0, indent.length - tab.length);\n            }\n        }\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        if (input != \"\\n\" && input != \"\\r\" && input != \"\\r\\n\")\n            return false;\n\n        if (line.match(/^\\s*[\\)\\}\\]]$/))\n            return true;\n\n        var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;\n\n        if (!tokens || !tokens.length)\n            return false;\n\n        return (tokens[0].type == \"keyword\" && outdentKeywords.indexOf(tokens[0].value) != -1);\n    };\n\n    this.autoOutdent = function(state, session, row) {\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine).length;\n        var prevTokens = this.getTokenizer().getLineTokens(prevLine, \"start\").tokens;\n        var tabLength = session.getTabString().length;\n        var expectedIndent = prevIndent + tabLength * getNetIndentLevel(prevTokens);\n        var curIndent = this.$getIndent(session.getLine(row)).length;\n        if (curIndent <= expectedIndent) {\n            return;\n        }\n        session.outdentRows(new Range(row, 0, row + 2, 0));\n    };\n\n    this.createWorker = function(session) {\n        var worker = new WorkerClient([\"ace\"], require(\"../worker/lua\"), \"Worker\");\n        worker.attachToDocument(session.getDocument());\n        \n        worker.on(\"annotate\", function(e) {\n            session.setAnnotations(e.data);\n        });\n        \n        worker.on(\"terminate\", function() {\n            session.clearAnnotations();\n        });\n        \n        return worker;\n    };\n\n    this.$id = \"ace/mode/lua\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});\n"],"sourceRoot":""}